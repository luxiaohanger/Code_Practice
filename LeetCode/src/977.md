# 有序数组的平方
给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。
## Way1 平方后排序
但是其实大小已经排好了，只是需要左右比较
## Way2 从最小值开始双指针
```c++
vector<int> sortedSquares(vector<int>& nums) {
    if(!nums.size())return nums;
    int min=abs(nums[0]);
    int index=0;
    for(int i=0;i<nums.size();i++) {
        if(abs(nums[i])<min) {
            min=abs(nums[i]);
            index=i;
        }
    }
    //i!=j 否则多算一次
    int i=index,j=i+1;
    vector<int> ans;
    while(i>=0||j<nums.size()) {
        if(i<0){
            ans.push_back(nums[j]*nums[j]);
            j++;
        }else if(j>=nums.size()) {
            ans.push_back(nums[i]*nums[i]);
            i--;
        }else {
            if(abs(nums[i])>abs(nums[j])) {
                ans.push_back(nums[j]*nums[j]);
                j++;
            }else {
                ans.push_back(nums[i]*nums[i]);
                i--;
            }
        }
    }
    return ans;
}
```
## Way3 逆序双指针
***既然能正序排列，自然能逆序排列***  
此时无需找最小值，从两边直接找较大值即可
```c++
vector<int> sortedSquares(vector<int>& nums) {
    int n=nums.size();
    if(!n)return nums;
    vector<int> ans(n);
    int i=0,j=n-1,k=n-1;
    while(k>=0) {
        if(abs(nums[i])>abs(nums[j])) {
            ans[k--]=nums[i]*nums[i];
            i++;
        }else {
            ans[k--]=nums[j]*nums[j];
            j--;
        }
    }
    return  ans;
}
```
